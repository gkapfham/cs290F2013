\documentclass[12pt,epsf,psfig,graphics]{article}             
\textwidth = 6.5in
\textheight = 9.05in
\topmargin 0.0in
\oddsidemargin 0.0in
\evensidemargin 0.0in

% set it so that subsubsections have numbers and they
% are displayed in the TOC (maybe hard to read, might want to disable)

\usepackage[T1]{fontenc}
\usepackage{mathptmx}

%\usepackage{graphics}

\setcounter{secnumdepth}{3}
\setcounter{tocdepth}{3}

% define widow protection 
        
\def\widow#1{\vskip #1\vbadness10000\penalty-200\vskip-#1}

% define a little section heading that doesn't go with any number

\def\littlesection#1{
\widow{2cm}
\vskip 0.5cm
\noindent{\bf #1}
\vskip 0.1cm
\noindent
}

% A paraphrase mode that makes it easy to see the stuff that shouldn't
% stay in for the final proposal

\newdimen\tmpdim
\long\def\paraphrase#1{{\parskip=0pt\hfil\break
\tmpdim=\hsize\advance\tmpdim by -15pt\noindent%
\hbox to \hsize
{\vrule\hskip 3pt\vrule\hfil\hbox to \tmpdim{\vbox{\hsize=\tmpdim
\def\par{\leavevmode\endgraf}
\obeyspaces \obeylines 
\let\par=\endgraf
\bf #1}}}}}

\renewcommand{\baselinestretch}{1.2}    % must go before the begin of doc
\newtheorem{principle}{Principle}
\newtheorem{definition}{Definition}
\newtheorem{define}{Definition}
% go with the way that CC sets the margins

\begin{document}

% handle widows appropriately
\def\widow#1{\vskip #1\vbadness10000\penalty-200\vskip-#1}

\begin{center}

CS290: Principles of Software Development \\
First Examination \\
%Saturday December 11, 2004 \\

\end{center}

\noindent
Answer the five questions that are listed below.  You must provide
answers to these questions on a separate sheet of paper.  Please
develop responses that clearly express your ideas in the most succinct
manner possible.  You are not permitted to complete this examination
in conjunction with any of your classmates.  Furthermore, you cannot
consult any outside references during this examination.  If you have
questions concerning the problems that are given below, then please
visit my office during the examination period.  If you leave the
classroom to take the exam, then you are responsible for checking the
white board for status updates.

%\mbox{} \newline
%\mbox{} \newline

\begin{enumerate}
  
\item ({\bf 10 Points}) In {\em The Mythical Man Month} Frederick
  Brooks states that there is no {\em silver bullet} for the field of
  software engineering.  That is, he believes that there is no
  technical or managerial development that will offer an order of
  magnitude improvement in productivity. In order to support his
  argument, Brooks describes several concepts in light of the
  productivity equation provided in Equation~\ref{productivity}.

        \begin{equation} \label{productivity}
        \mbox{{\em Time of task}} = \sum_{i = 1}^{n} 
                \mbox{{\em Frequency}}_i \times \mbox{{\em Time}}_i
        \end{equation}

        \begin{enumerate}
          
        \item ({\bf 4 Points}) Explain the notions of {\em essence}
          and {\em accident} as Frederick Brooks defines them in the
          {\em Mythical Man Month}.  Give one or two examples of each
          concept.
          
        \item ({\bf 4 Points}) Using Equation~\ref{productivity},
          explain why Brooks asserts that there is no silver bullet to
          solve the problems that are associated with constructing
          software.
        
        \item ({\bf 2 Points}) Brooks states that software engineers
          have developed a number of potential silver bullets.
          Discuss two candidates for silver bullets and state whether
          or not you believe that they are indeed silver bullets.

       \end{enumerate}
        
\newpage

\item ({\bf 10 Points}) Software process models are used as
  abstractions that can help to explain different approaches to
  software development. Respond to the following questions about how
  process models can guide the creation of software systems.

        \begin{enumerate}
          
        \item ({\bf 4 Points}) Discuss the fundamental ``phases'' that
          are common to most software processes.  Provide a one or two
          sentence description of each activity.  Please include an
          example of one or two tools that can support each of these
          activities. If no tool support is available, then clearly
          state why this is the case!  Your response should include a
          properly labeled figure that includes the phase and its
          input and output.
          
        \item ({\bf 2 Points}) After clearly explaining the halting
          problem, select one phase of the software lifecycle and
          discuss how the halting problem is relevant to an activity
          in this phase.

        \item ({\bf 2 Points}) Explain the similarities and
          differences between the waterfall lifecycle model (i.e., the
          ``traditional'' model that Pfleeger and Atlee initially
          describe in Chapter 2) and the spiral model proposed by
          Boehm.

        \item ({\bf 2 Points}) A node in an activity graph stands for
          a task or milestone in a software development project.  What
          is the meaning behind the nodes and edges in an activity
          graph when they have the following two configurations?

          \begin{enumerate}

            \item Nodes $N_i$ and $N_j$ that are connected by a
              directed and solid edge from $N_i$ to $N_j$

            \item Nodes $N_k$ and $N_l$ that are connected by a
              directed and dashed edge from $N_k$ to $N_l$

          \end{enumerate}

        \end{enumerate}

\newpage

\item ({\bf 10 Points}) Testing is a part of the software lifecycle
  that can be used for many different purposes.  Provide a response 
  to each of the following questions about testing.

\begin{enumerate}       
  
\item ({\bf 2 Points}) Pfleeger and Atlee identify different types of
  activities such as unit, integration, and system testing.  What is
  the motivation behind performing these tasks?

\item ({\bf 2 Points}) Software testing is useful because of the
  benefits that you enumerated in response to the first part of this
  question.  Yet, testing has several different limitations.  Discuss
  two of the limitations commonly associated with software testing.
  
\item ({\bf 2 Points}) What are the similarities and differences
  between the implementation and testing of hardware and software?  Is
  it easier to test hardware or software?  Why?

\item ({\bf 4 Points}) Verification and validation are two activities
  that software engineers commonly perform during the construction of
  a software application.  In your response to this part of the
  question, please define both of these terms and for each term
  furnish a concrete example of an associated activity.
  
\end{enumerate}

\newpage

\item ({\bf 10 Points}) Managers often use a software process in order
  to make decisions about when to release an application.  For
  example, suppose that you are a manager and you are determining
  which features will be a part of the next release of your program.
  Moreover, assume that for each new requirement $R_j$ you already
  know $C_j$, the cost associated with implementing the requirement
  and $B_j$, the monetary benefit for a program that contains this
  feature.

  In order to determine which requirements will be part of the next
  release for your application, you must choose from the requirements
  $R = \{ R_1, \ldots, R_n \}$ and ensure that (i) the implementation
  tasks are completed at no more than the total fixed cost $C$ and
  (ii) you maximize the total monetary benefit that your company will
  see when they release the tool.  Given cost and benefit information
  for each $R_j$ and the fixed cost $C$, how will you determine which
  requirements are included in the next release of your program?
    
\newpage

\item ({\bf 10 Points}) Software implementation is the process of
  translating the software specification, design, and architecture
  into an executable representation.  Answer the following questions
  about the implementation and evaluation of computer software.

\begin{enumerate}

  \item ({\bf 3 Points}) Implement a data generator that takes a list
    of numbers as input and then produces a list of lists as output.
    For instance, please consider the following outputs for the input
    list 1 2 3 4.  From this example, you can see that the data
    generator must return all of the lists that may be obtained by
    swapping certain items in the input list.  In this specific
    instance, an input list of size four produces an output list that
    contains six individual lists.  You may implement your data
    generator in any programming language.

    \begin{enumerate}

    \item 2 1 3 4
      
    \item 3 2 1 4

    \item 4 2 3 1

    \item 1 3 2 4
        
    \item 1 4 3 2

    \item 1 2 4 3

  \end{enumerate}

  \item ({\bf 3 Points}) Provide a test plan for the data generator
    that you implemented in Part 9a of this question.  Your plan
    should identify the inputs and anticipated output for each of the
    tests.  You should also clearly explain why you decided to include
    each of the test cases into the overall plan.

  \item ({\bf 4 Points}) Jeffrey Voas poses the question ``can clean
    pipes produce dirty water?'' in an article of the same title from
    IEEE Software.  What is the meaning behind the concepts of ``clean
    pipes'' and ``dirty water''?  In the context of software
    engineering, what is your response to the question raised by Voas?

\end{enumerate}

\end{enumerate}

\end{document}
