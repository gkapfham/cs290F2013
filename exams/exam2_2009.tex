\documentclass[12pt,epsf,psfig,graphics]{article}             
\textwidth = 6.5in
\textheight = 9.05in
\topmargin 0.0in
\oddsidemargin 0.0in
\evensidemargin 0.0in

% set it so that subsubsections have numbers and they
% are displayed in the TOC (maybe hard to read, might want to disable)

\usepackage[T1]{fontenc}
\usepackage{mathptmx}

%\usepackage{graphics}

\setcounter{secnumdepth}{3}
\setcounter{tocdepth}{3}

% define widow protection 
        
\def\widow#1{\vskip #1\vbadness10000\penalty-200\vskip-#1}

% define a little section heading that doesn't go with any number

\def\littlesection#1{
\widow{2cm}
\vskip 0.5cm
\noindent{\bf #1}
\vskip 0.1cm
\noindent
}

% A paraphrase mode that makes it easy to see the stuff that shouldn't
% stay in for the final proposal

\newdimen\tmpdim
\long\def\paraphrase#1{{\parskip=0pt\hfil\break
\tmpdim=\hsize\advance\tmpdim by -15pt\noindent%
\hbox to \hsize
{\vrule\hskip 3pt\vrule\hfil\hbox to \tmpdim{\vbox{\hsize=\tmpdim
\def\par{\leavevmode\endgraf}
\obeyspaces \obeylines 
\let\par=\endgraf
\bf #1}}}}}

\renewcommand{\baselinestretch}{1.2}    % must go before the begin of doc
\newtheorem{principle}{Principle}
\newtheorem{definition}{Definition}
\newtheorem{define}{Definition}
% go with the way that CC sets the margins

\begin{document}

% handle widows appropriately
\def\widow#1{\vskip #1\vbadness10000\penalty-200\vskip-#1}

\begin{center}

CS290: Principles of Software Development \\
Second Examination \\
%Saturday December 11, 2004 \\

\end{center}

\noindent
Answer the five questions that are listed on the following pages.  You
must provide answers to these questions on a separate sheet of paper.
Please develop responses that clearly express your ideas in the most
succinct manner possible.  You are not permitted to complete this
examination in conjunction with any of your classmates.  Furthermore,
you cannot consult any outside references during this examination.  If
you have questions concerning the problems that are given below, then
please visit my office during the examination period.  If you leave
the classroom to take the exam, then you are responsible for checking
the white board for status updates.

%\mbox{} \newline
%\mbox{} \newline

\begin{enumerate}
  
\item ({\bf 10 Points}) Hamlet and Maybee outline several suggestions
  for the creation of a high quality requirements document.  Answer
  the following questions about the requirements elicitation and
  analysis phase of the software lifecycle.

        \begin{enumerate}
          
        \item ({\bf 5 Points}) Hamlet and Maybee stress that
          requirements should be {\em non-prescriptive} in nature.
          After defining what this term means, please provide an
          example of a requirement that is non-prescriptive and
          another that fails to adhere to this standard.

        \item ({\bf 5 Points}) Suppose that you are part of a
          development team that is responsible for implementing a
          compiler for the Java programming language.  The manager of
          your team asks you to fully implement {\em array-bounds
            checking} in your compiler.  After defining what this term
          means, explain whether or not this requirement is {\em
            feasible}.

       \end{enumerate}
        
\newpage

\item ({\bf 10 Points}) Mutation testing and random testing have both
  emerged as techniques that can be used during the verification and
  validation process.  Answer the following question about mutation
  testing and use the definitions below to respond to
  Part~\ref{compare}.

\begin{define}

If P is a program to implement function F on domain D, then a test set
T $ \subset $ D is adequate for P and F if ( $\forall$ programs Q ),
$[Q(D) \neq F(D) ] \Rightarrow [(\exists t \in T) (Q(t) \neq F(t))]$.

\label{adeq}
\end{define}

\begin{define}

If P is a program to implement function F on domain D and $\Phi$ is a
finite collection of programs, then a test set T $ \subset $ D is
adequate for P relative to $\Phi$ if ( $\forall$ programs Q $\in \Phi$
), $[Q(D) \neq F(D) ] \Rightarrow [(\exists t \in T) (Q(t) \neq
  F(t))]$.

\label{rel}
\end{define}

\begin{enumerate}

\item \label{compare} ({\bf 3 Points}) Definitions~\ref{adeq} and
  \ref{rel} provide a description of the terms {\em adequate} and {\em
    relative adequate}.  Using these definitions, explore the
  similarities and differences between the terms adequate and relative
  adequate.  How are these definitions related to the application of
  mutation testing to a Java program $P$ and a JUnit test suite $T$?

\item \label{purpose} ({\bf 3 Points}) What is the main reason for
  performing mutation testing? Next, suppose that a given test suite
  $T$ is able to kill $80\%$ of the syntactic mutants in the set
  $\Phi$.  How should this influence the remainder of the testing
  effort?

%% \item ({\bf 2 Points}) Suppose that you are developing a mutation
%%   testing tool for relational operators.  If your tool encountered the
%%   statement {\tt if(num\_deposits > MAX\_DEPOSITS)}, what syntactic
%%   mutants would you generate to populate the set $\Phi$?

\item ({\bf 4 Points}) Existing tools such as Randoop and Eclat
  implement different types of random testing techniques.  After
  clearly defining the term {\em random testing}, please provide one
  strength and one weakness of this approach to verification and
  validation.  

%% \item ({\bf 2 Points}) Mutation testing can be a very powerful
%%   technique during the phase of verification and validation.  However,
%%   it also has several important limitations.  Discuss two of the major
%%   limitations of mutation testing.  Your response should provide the
%%   name of one or two mutation testing tools that are available for the
%%   Java programming language.

\end{enumerate}

\newpage

\item ({\bf 10 Points}) Sommerville describes several different types
  of requirements that software engineers may express in a document.
  Answer the following questions about the different types of
  requirements that may emerge during the requirements elicitation and
  analysis phase of the software lifecycle.

  \begin{enumerate}
          
        \item ({\bf 5 Points}) Sommerville explains that there are
          three key types of requirements: {\em functional}, {\em
            non-functional}, and {\em domain}.  Please furnish a clear
          definition of each of these types of requirements.  For two
          of these types, you should also provide a concrete example
          of a requirement that illustrates your definition.

        \item ({\bf 3 Points}) It is possible to measure many
          different {\em properties} of a software system.  For
          instance, a team may want to evaluate the speed, size, ease
          of use, reliability, robustness, or portability of an
          application.  Pick three of these properties and explain a
          metric that we could use to quantify how well the software
          exhibits the characteristic.

        \item ({\bf 2 Points}) After conducting an empirical
          investigation of software errors, Basili and Perricone draw
          the following conclusion: ``48 percent of faults observed in
          a medium-scale software project were attributed to incorrect
          or misinterpreted functional specifications or
          requirements.''  In your opinion, why is this the case?

       \end{enumerate}

\newpage

\item ({\bf 10 Points}) Pfleeger and Atlee examine many of the
  challenges that are associated with correctly specifying a software
  system.  Answer the following questions that are related to
  measuring the characteristics of software requirements.

  \begin{enumerate}
          
        \item ({\bf 6 Points}) It is important to develop ways to rate
          the quality of a requirements document since the individual
          requirements are used by the designers, implementers, and
          testers throughout the remainder of the lifecycle.  Pfleeger
          and Atlee outline the following scale for evaluating a
          requirement:

          \begin{itemize}

          \item 1 - You (the designer) understand this requirement
            completely, you have designed from similar requirements in
            the past, and you should have no trouble developing a
            design from this requirement.

          \item 2 - There are elements of this requirement that are
            new to you, but they are not radically different from
            requirements that you have successfully designed from in
            the past.

          \item 3 - There are elements of this requirements that are
            very different from requirements that you have designed
            from in the past, but you understand the requirement and
            you think that you can develop a good design from it.

          \item 4 - There are parts of this requirement that you do
            not understand, and you are not sure that you can develop
            a good design.

          \item 5 - You do not understand this requirement at all, and
            you cannot develop a design for it.

          \end{itemize}

          Using this rating scheme, it is possible to determine
          whether or not a software development team should start to
          design and implement the system.  As part of your response
          to this question, please draw two {\em histograms} where the
          vertical axis is the {\em number} of requirements in each of
          the above categories and the horizontal axis gives the {\em
            categories} in numerically increasing order (i.e., 1 to
          5).  One of the histograms must represent a system that is
          ready to leave the requirements elicitation and analysis
          phase and the other should reveal that it is not advisable
          to start the architecture and design phase.

        \item ({\bf 4 Points}) One suggestion for improving a
          requirements document is to replace pronouns with specific
          nouns.  After defining the terms {\em pronoun} and {\em
            noun} and giving an example that you might find in a
          requirements document, you should briefly explain the
          benefits and drawbacks associated with following this rule
          as you write requirements.

       \end{enumerate}
        
\newpage

\item ({\bf 10 Points}) Testing, model checking, and theorem proving
  are all useful methods for finding faults in specifications and/or
  implementations.  Answer the following questions about these
  recently emerging techniques.

  \begin{enumerate}
          
  \item ({\bf 3 Points}) The software engineers and researchers at
    Google found a defect in the traditional implementation of the
    binary search.  What was the defect in this algorithm?  Your
    response should clearly explain the situation(s) in which this
    fault would manifest itself as a failing execution of a program.

  \item ({\bf 2 Points}) Dwyer et al.\ explore the use of a {\em model
    checker} during the process of computer-aided verification.  What
    is model checking and how can it reveal errors in a specification
    and/or an implementation?

  \item ({\bf 3 Points}) Dwyer et al.\ describe a new technique called
    parallel randomized state-space search (PRSS). How does PRSS
    improve the model checking process?  What are the strengths and
    weaknesses of this approach?

    \item ({\bf 2 Points}) The experiments conducted by Dwyer et
     al.\ focus on model checking the specification of programs that
      range from between 65 and 934 lines of executable source code
      and 3 to 13 individual threads.  Even though these programs have
      relatively few lines of code, the model checking of the
      specification and implementation of these programs can incur a
      substantial time and space overhead.  Why is this the case?

  \end{enumerate}

\end{enumerate}

\end{document}
